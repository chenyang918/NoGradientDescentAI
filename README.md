# 超级解方法

#### 介绍
从上面的方法可进一步推理 出 任何 向量@一个单位向量 =[1]  就能用来求解 任意 向量乘法的解。

而一个向量只要比上自己的sum 方可 @单位向量 =[1] 任意一个向量都可以用来求解 向量乘法的解

故而要有数据约束 才可直到 用哪些向量求解

    #  假设这个向量为B =[b1,b2,b3,b4,......bn]  sum(B)=[1]
    #  k*B=k*[b1,b2,b3,b4,......bn]  k*B@I(T)=k*[1]
    #  A@x(T)=[k]=k*[1]=k*B@I(T) =[b1,b2,b3,b4,......bn] * k
    #  [1*x1,2*x2,3*x3,.....n*xn]=[b1,b2,b3,b4,......bn] * k  
    #  [1*x1=b1*k,2*x2=b2*k,...n*xn=bn*k] 
    #  多个输入多个输出产生多个解 最后选择针对数据集公用解 才可通用模型
    #  直接使用不通输入和输出 权重行数个 就能通过列向量求解方程通解 见代码yan_zheng.py
    #  等比法只能求一个 输入 一个输出的解不是通解就不做介绍了
    #  一个权重的行数决定了权重能够表达数据的复杂度
这个通用解的方法只需要将数据分割串联方可实现生成网络

重点在于如何选择用于求解的数据
大致方法是 计算数据的所有相对0点的距离排序 后 平均选择数据 根据自己的数据数量合理的设计权重行数
方可

通过数据分割串联 方可实现 多个 叠加 

如何建立 非线性（使用激活函数） 可以  直接对输出数据进行激活函数后 输入到另一个 层 输出还是输出

这样方可非线性  本身数据拟合就是针对未参与的数据的，所以 输出数据和输入数据等价。

由于输入数据的维度决定了权重的行数 也就是决定了需要参考数据的量 所以有的时候需要更多的数据进行

模拟才能达到效果  所以要使用 一个等差矩阵来扩充输入的维度。也就是扩展权重的行数 ，使用数据的量

使用的后要数据量要和使用后的维度一致 
